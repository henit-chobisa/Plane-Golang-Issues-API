// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: issues.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/google/uuid"
)

const createIssue = `-- name: CreateIssue :one
INSERT INTO "issues" (
    "id",
    "description",
    "priority",
    "start_date",
    "target_date",
    "created_by_id",
    "project_id"
)
VALUES (
    gen_random_uuid(),
    $1,
    $2,
    $3,
    $4,
    $5,
    $6
) RETURNING id, description, priority, start_date, target_date, created_by_id, project_id, state_id
`

type CreateIssueParams struct {
	Description sql.NullString `json:"description"`
	Priority    int32          `json:"priority"`
	StartDate   sql.NullTime   `json:"start_date"`
	TargetDate  sql.NullTime   `json:"target_date"`
	CreatedByID uuid.UUID      `json:"created_by_id"`
	ProjectID   uuid.UUID      `json:"project_id"`
}

func (q *Queries) CreateIssue(ctx context.Context, arg CreateIssueParams) (Issue, error) {
	row := q.db.QueryRowContext(ctx, createIssue,
		arg.Description,
		arg.Priority,
		arg.StartDate,
		arg.TargetDate,
		arg.CreatedByID,
		arg.ProjectID,
	)
	var i Issue
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.Priority,
		&i.StartDate,
		&i.TargetDate,
		&i.CreatedByID,
		&i.ProjectID,
		&i.StateID,
	)
	return i, err
}

const deleteIssue = `-- name: DeleteIssue :exec
DELETE FROM "issues" WHERE "id" = $1
`

func (q *Queries) DeleteIssue(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteIssue, id)
	return err
}

const getIssue = `-- name: GetIssue :one
SELECT id, description, priority, start_date, target_date, created_by_id, project_id, state_id FROM "issues"
WHERE id=$1 LIMIT 1
`

func (q *Queries) GetIssue(ctx context.Context, id uuid.UUID) (Issue, error) {
	row := q.db.QueryRowContext(ctx, getIssue, id)
	var i Issue
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.Priority,
		&i.StartDate,
		&i.TargetDate,
		&i.CreatedByID,
		&i.ProjectID,
		&i.StateID,
	)
	return i, err
}

const listIssuesByProject = `-- name: ListIssuesByProject :many
SELECT
    json_build_object(
        'name', i.id,
        'description', i.description,
        'priority', i.priority,
        'start_date', i.start_date,
        'target_date', i.target_date,
        'state_detail', json_build_object(
            'name', s.id,
            'color', s.color
        ),
        'user', json_build_object(
            'username', u.username,
            'email', u.email
        ),
        'project', json_build_object(
            'name', p.name,
            'description', p.description
        )
    ) AS issue_data
FROM
    issues i
JOIN
    projects p ON i.project_id = p.id
JOIN
    users u ON i.created_by_id = u.id
JOIN
    states s ON i.state_id = s.id
WHERE
    p.id = $1
`

func (q *Queries) ListIssuesByProject(ctx context.Context, id uuid.UUID) ([]json.RawMessage, error) {
	rows, err := q.db.QueryContext(ctx, listIssuesByProject, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []json.RawMessage
	for rows.Next() {
		var issue_data json.RawMessage
		if err := rows.Scan(&issue_data); err != nil {
			return nil, err
		}
		items = append(items, issue_data)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateIssue = `-- name: UpdateIssue :exec
UPDATE "issues"
SET "priority" = $2, "target_date" = $3
WHERE "id" = $1
`

type UpdateIssueParams struct {
	ID         uuid.UUID    `json:"id"`
	Priority   int32        `json:"priority"`
	TargetDate sql.NullTime `json:"target_date"`
}

func (q *Queries) UpdateIssue(ctx context.Context, arg UpdateIssueParams) error {
	_, err := q.db.ExecContext(ctx, updateIssue, arg.ID, arg.Priority, arg.TargetDate)
	return err
}
