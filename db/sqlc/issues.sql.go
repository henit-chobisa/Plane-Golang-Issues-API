// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: issues.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createIssue = `-- name: CreateIssue :one
INSERT INTO "issues" (
    "id",
    "description",
    "priority",
    "start_date",
    "target_date",
    "created_by_id",
    "project_id"
)
VALUES (
    gen_random_uuid(),
    $1,
    $2,
    $3,
    $4,
    $5,
    $6
) RETURNING id, description, priority, start_date, target_date, created_by_id, project_id
`

type CreateIssueParams struct {
	Description sql.NullString `json:"description"`
	Priority    int32          `json:"priority"`
	StartDate   sql.NullTime   `json:"start_date"`
	TargetDate  sql.NullTime   `json:"target_date"`
	CreatedByID uuid.UUID      `json:"created_by_id"`
	ProjectID   uuid.UUID      `json:"project_id"`
}

func (q *Queries) CreateIssue(ctx context.Context, arg CreateIssueParams) (Issue, error) {
	row := q.db.QueryRowContext(ctx, createIssue,
		arg.Description,
		arg.Priority,
		arg.StartDate,
		arg.TargetDate,
		arg.CreatedByID,
		arg.ProjectID,
	)
	var i Issue
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.Priority,
		&i.StartDate,
		&i.TargetDate,
		&i.CreatedByID,
		&i.ProjectID,
	)
	return i, err
}

const deleteIssue = `-- name: DeleteIssue :exec
DELETE FROM "issues" WHERE "id" = $1
`

func (q *Queries) DeleteIssue(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteIssue, id)
	return err
}

const getIssue = `-- name: GetIssue :one
SELECT id, description, priority, start_date, target_date, created_by_id, project_id FROM "issues"
WHERE id=$1 LIMIT 1
`

func (q *Queries) GetIssue(ctx context.Context, id uuid.UUID) (Issue, error) {
	row := q.db.QueryRowContext(ctx, getIssue, id)
	var i Issue
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.Priority,
		&i.StartDate,
		&i.TargetDate,
		&i.CreatedByID,
		&i.ProjectID,
	)
	return i, err
}

const listIssuesByProject = `-- name: ListIssuesByProject :many
SELECT
    i.id AS issue_id,
    i.description AS issue_description,
    i.priority AS issue_priority,
    i.start_date AS issue_start_date,
    i.target_date AS issue_target_date,
    p.id AS project_id,
    p.name AS project_name,
    p.description AS project_description,
    u.id AS created_by_id,
    u.username AS created_by_username,
    u.email AS created_by_email
FROM
    issues i
JOIN
    projects p ON i.project_id = p.id
JOIN
    users u ON i.created_by_id = u.id
WHERE
    p.id = $1
`

type ListIssuesByProjectRow struct {
	IssueID            uuid.UUID      `json:"issue_id"`
	IssueDescription   sql.NullString `json:"issue_description"`
	IssuePriority      int32          `json:"issue_priority"`
	IssueStartDate     sql.NullTime   `json:"issue_start_date"`
	IssueTargetDate    sql.NullTime   `json:"issue_target_date"`
	ProjectID          uuid.UUID      `json:"project_id"`
	ProjectName        string         `json:"project_name"`
	ProjectDescription sql.NullString `json:"project_description"`
	CreatedByID        uuid.UUID      `json:"created_by_id"`
	CreatedByUsername  string         `json:"created_by_username"`
	CreatedByEmail     sql.NullString `json:"created_by_email"`
}

func (q *Queries) ListIssuesByProject(ctx context.Context, id uuid.UUID) ([]ListIssuesByProjectRow, error) {
	rows, err := q.db.QueryContext(ctx, listIssuesByProject, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListIssuesByProjectRow
	for rows.Next() {
		var i ListIssuesByProjectRow
		if err := rows.Scan(
			&i.IssueID,
			&i.IssueDescription,
			&i.IssuePriority,
			&i.IssueStartDate,
			&i.IssueTargetDate,
			&i.ProjectID,
			&i.ProjectName,
			&i.ProjectDescription,
			&i.CreatedByID,
			&i.CreatedByUsername,
			&i.CreatedByEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateIssue = `-- name: UpdateIssue :exec
UPDATE "issues"
SET "priority" = $2, "target_date" = $3
WHERE "id" = $1
`

type UpdateIssueParams struct {
	ID         uuid.UUID    `json:"id"`
	Priority   int32        `json:"priority"`
	TargetDate sql.NullTime `json:"target_date"`
}

func (q *Queries) UpdateIssue(ctx context.Context, arg UpdateIssueParams) error {
	_, err := q.db.ExecContext(ctx, updateIssue, arg.ID, arg.Priority, arg.TargetDate)
	return err
}
